<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NiiVue Viewer – GT vs Prediction (Per-layer Labels 1/2/3)</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    #toolbar {
      position: absolute; top: 10px; left: 10px; z-index: 10;
      background: rgba(0,0,0,0.72); color: #fff; font-family: system-ui, sans-serif; font-size: 14px;
      padding: 12px; border-radius: 12px; min-width: 320px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.35);
    }
    #toolbar h3 { margin: 0 0 8px; font-size: 15px; }
    #toolbar label { display: block; margin: 6px 0; cursor: pointer; }
    #toolbar hr { border: none; border-top: 1px solid rgba(255,255,255,0.12); margin: 10px 0; }
    .hint { color: #bbb; font-size: 12px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 4px 16px; }
    .section { margin-top: 6px; padding: 6px 8px; background: rgba(255,255,255,0.06); border-radius: 8px; }
    canvas { width: 100%; height: 100%; display: block; }
  </style>
  <script src="./js/niivue.umd.js"></script>
</head>
<body>
  <div id="toolbar">
    <h3>Layers</h3>
    <label><input type="checkbox" id="showGT" checked> Show Ground Truth</label>
    <label><input type="checkbox" id="showPred" checked> Show Prediction</label>
    <label>Opacity:
      <input type="range" id="opacity" min="0" max="1" step="0.05" value="0.6">
    </label>
    <hr>
    <div class="section">
      <h3>GT labels</h3>
      <div class="row">
        <label><input type="checkbox" id="gtKidney" checked> 1 · kidney</label>
        <label><input type="checkbox" id="gtTumor"  checked> 2 · tumor</label>
        <label><input type="checkbox" id="gtCyst"   checked> 3 · cyst <span id="gtCystNote" class="hint"></span></label>
      </div>
    </div>
    <div class="section">
      <h3>Pred labels</h3>
      <div class="row">
        <label><input type="checkbox" id="predKidney" checked> 1 · kidney</label>
        <label><input type="checkbox" id="predTumor"  checked> 2 · tumor</label>
        <label><input type="checkbox" id="predCyst"   checked> 3 · cyst <span id="predCystNote" class="hint"></span></label>
      </div>
    </div>
    <div class="hint" style="margin-top:8px;">
      If a label is absent in GT or Pred, its checkbox will be disabled for that layer only.
    </div>
  </div>

  <canvas id="gl"></canvas>

<script>
window.addEventListener('load', async () => {
  const NiiVueClass = window.Niivue || (window.niivue && window.niivue.Niivue);
  const NVImageClass = (window.niivue && window.niivue.NVImage) || window.NVImage;
  if (!NiiVueClass || !NVImageClass) {
    console.error("Niivue or NVImage not found. Check ./js/niivue.umd.js path.");
    return;
  }

  const nv = new NiiVueClass({
    show3Dcrosshair: true,
    isWebGL2: true,
    logging: true
  });
  nv.attachTo('gl');

  const base =
    (location.hostname.endsWith("github.io") ? location.origin + location.pathname.replace(/[^/]+$/, "") : "./") +
    "case_00003/";

  const files = {
    img:  base + "imaging_float32_lowres.nii",
    gt:   base + "segmentation_aligned_lowres.nii",
    pred: base + "case_00003_aligned_lowres.nii"
  };

  async function fetchArrayBuffer(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error("HTTP " + r.status + " for " + url);
    return await r.arrayBuffer();
  }

  function makeLabelLUT(a1, a2, a3) {
    return {
      R: [0, 0, 255, 255],
      G: [0, 255, 0, 255],
      B: [0, 255, 255, 0],
      A: [0, a1, a2, a3],
      I: [0, 1, 2, 3],
      labels: ["background", "kidney", "tumor", "cyst"]
    };
  }

  let idxImage = -1, idxGT = -1, idxPred = -1;

  try {
    const [bufImg, bufGT, bufPred] = await Promise.all([
      fetchArrayBuffer(files.img),
      fetchArrayBuffer(files.gt),
      fetchArrayBuffer(files.pred)
    ]);

    const img  = (NVImageClass.loadFromArrayBuffer
                  ? await NVImageClass.loadFromArrayBuffer({ arrayBuffer: bufImg,  name: "imaging_float32_lowres.nii" })
                  : (nv.loadFromArrayBuffer && await nv.loadFromArrayBuffer(bufImg,  "imaging_float32_lowres.nii")));
    const gt   = (NVImageClass.loadFromArrayBuffer
                  ? await NVImageClass.loadFromArrayBuffer({ arrayBuffer: bufGT,   name: "segmentation_aligned_lowres.nii" })
                  : (nv.loadFromArrayBuffer && await nv.loadFromArrayBuffer(bufGT,   "segmentation_aligned_lowres.nii")));
    const pred = (NVImageClass.loadFromArrayBuffer
                  ? await NVImageClass.loadFromArrayBuffer({ arrayBuffer: bufPred, name: "case_00003_aligned_lowres.nii" })
                  : (nv.loadFromArrayBuffer && await nv.loadFromArrayBuffer(bufPred, "case_00003_aligned_lowres.nii")));

    if (!img || !gt || !pred) throw new Error("ArrayBuffer loader not available in this build");

    nv.addVolume(img);
    nv.addVolume(gt);
    nv.addVolume(pred);

    nv.volumes.forEach((v, i) => {
      if (v.name?.includes("imaging_float32_lowres")) idxImage = i;
      if (v.name?.includes("segmentation_aligned_lowres")) idxGT = i;
      if (v.name?.includes("case_00003_aligned_lowres")) idxPred = i;
    });

    if (idxImage >= 0) {
      nv.volumes[idxImage].name = "Image";
      nv.volumes[idxImage].opacity = 1.0;
      if (nv.setColormap) nv.setColormap(nv.volumes[idxImage].id, "gray");
    }
    if (idxGT >= 0) {
      nv.volumes[idxGT].name = "GT";
      nv.volumes[idxGT].opacity = 0.6;
      const lut = makeLabelLUT(160,160,160);
      if (typeof nv.volumes[idxGT].setColormapLabel === "function") {
        nv.volumes[idxGT].setColormapLabel(lut);
      } else {
        nv.volumes[idxGT].colormapLabel = lut;
      }
    }
    if (idxPred >= 0) {
      nv.volumes[idxPred].name = "Pred";
      nv.volumes[idxPred].opacity = 0.6;
      const lut = makeLabelLUT(160,160,160);
      if (typeof nv.volumes[idxPred].setColormapLabel === "function") {
        nv.volumes[idxPred].setColormapLabel(lut);
      } else {
        nv.volumes[idxPred].colormapLabel = lut;
      }
    }
    nv.updateGLVolume();
  } catch (e) {
    console.error("Failed to load volumes (arrayBuffer path):", e);
    return;
  }

  async function hasLabel(iVol, value) {
    const v = nv.volumes[iVol];
    if (!v) return false;
    const data = v.img || (v.img2RAS && v.img2RAS());
    if (!data) return false;
    for (let k = 0; k < data.length; k++) if (data[k] === value) return true;
    return false;
  }

  const gtCB   = document.getElementById('showGT');
  const predCB = document.getElementById('showPred');
  const opSL   = document.getElementById('opacity');

  function applyLayerUI() {
    const val = parseFloat(opSL.value);
    if (idxGT   >= 0) nv.volumes[idxGT].opacity  = gtCB.checked   ? val : 0.0;
    if (idxPred >= 0) nv.volumes[idxPred].opacity = predCB.checked ? val : 0.0;
    nv.updateGLVolume();
  }
  gtCB.addEventListener('change', applyLayerUI);
  predCB.addEventListener('change', applyLayerUI);
  opSL.addEventListener('input',  applyLayerUI);
  applyLayerUI();

  const gtKidney = document.getElementById('gtKidney');
  const gtTumor  = document.getElementById('gtTumor');
  const gtCyst   = document.getElementById('gtCyst');
  const gtCystNote = document.getElementById('gtCystNote');

  const predKidney = document.getElementById('predKidney');
  const predTumor  = document.getElementById('predTumor');
  const predCyst   = document.getElementById('predCyst');
  const predCystNote = document.getElementById('predCystNote');

  function makeAndApplyLUT(volIndex, kOn, tOn, cOn) {
    const lut = makeLabelLUT(kOn ? 160 : 0, tOn ? 160 : 0, cOn ? 160 : 0);
    if (volIndex >= 0) {
      if (typeof nv.volumes[volIndex].setColormapLabel === "function") {
        nv.volumes[volIndex].setColormapLabel(lut);
      } else {
        nv.volumes[volIndex].colormapLabel = lut;
      }
    }
  }

  function applyAllLabelVisibility() {
    makeAndApplyLUT(idxGT,   gtKidney.checked,  gtTumor.checked,  gtCyst.checked);
    makeAndApplyLUT(idxPred, predKidney.checked, predTumor.checked, predCyst.checked);
    nv.updateGLVolume();
  }

  gtKidney.addEventListener('change', applyAllLabelVisibility);
  gtTumor .addEventListener('change', applyAllLabelVisibility);
  gtCyst  .addEventListener('change', applyAllLabelVisibility);
  predKidney.addEventListener('change', applyAllLabelVisibility);
  predTumor .addEventListener('change', applyAllLabelVisibility);
  predCyst  .addEventListener('change', applyAllLabelVisibility);

  (async () => {
    if (idxGT >= 0) {
      const exist3 = await hasLabel(idxGT, 3);
      if (!exist3) {
        gtCyst.checked = false;
        gtCyst.disabled = true;
        gtCystNote.textContent = " (no cyst in GT)";
      }
    }
    if (idxPred >= 0) {
      const exist3 = await hasLabel(idxPred, 3);
      if (!exist3) {
        predCyst.checked = false;
        predCyst.disabled = true;
        predCystNote.textContent = " (no cyst in Pred)";
      }
    }
    applyAllLabelVisibility();
  })();
});
</script>
</body>
</html>
