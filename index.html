<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NiiVue Viewer – GT (warm labels) vs Pred (cool labels)</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    #toolbar {
      position: fixed; top: 10px; left: 10px; z-index: 9999;
      background: rgba(0,0,0,0.72); color: #fff; font-family: system-ui, sans-serif; font-size: 14px;
      padding: 12px; border-radius: 12px; min-width: 360px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.35);
      pointer-events: auto;
    }
    #toolbar h3 { margin: 0 0 8px; font-size: 15px; }
    #toolbar label { display: block; margin: 6px 0; cursor: pointer; }
    #toolbar hr { border: none; border-top: 1px solid rgba(255,255,255,0.12); margin: 10px 0; }
    .hint { color: #bbb; font-size: 12px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 4px 16px; }
    .section { margin-top: 6px; padding: 6px 8px; background: rgba(255,255,255,0.06); border-radius: 8px; }
    canvas { width: 100%; height: 100%; display: block; position: relative; z-index: 0; }
  </style>
  <script src="./js/niivue.umd.js"></script>
</head>
<body>
  <div id="toolbar">
    <h3>Layers</h3>
    <label><input type="checkbox" id="showGT" checked> Show Ground Truth (warm)</label>
    <label><input type="checkbox" id="showPred" checked> Show Prediction (cool)</label>
    <label>Mask opacity:
      <input type="range" id="opacity" min="0" max="1" step="0.05" value="0.6">
    </label>

    <hr>
    <div class="section">
      <h3>GT labels (warm)</h3>
      <div class="row">
        <label><input type="checkbox" id="gtKidney" checked> 1 · kidney</label>
        <label><input type="checkbox" id="gtTumor"  checked> 2 · tumor</label>
        <label><input type="checkbox" id="gtCyst"   checked> 3 · cyst <span id="gtCystNote" class="hint"></span></label>
      </div>
    </div>

    <div class="section">
      <h3>Pred labels (cool)</h3>
      <div class="row">
        <label><input type="checkbox" id="predKidney" checked> 1 · kidney</label>
        <label><input type="checkbox" id="predTumor"  checked> 2 · tumor</label>
        <label><input type="checkbox" id="predCyst"   checked> 3 · cyst <span id="predCystNote" class="hint"></span></label>
      </div>
    </div>

    <div class="hint" style="margin-top:8px;">
      Per-label toggles are bound to the actual label values detected in the volumes (sorted ascending).
    </div>
  </div>

  <canvas id="gl"></canvas>

<script>
window.addEventListener('load', async () => {
  const NiiVueClass = window.Niivue || (window.niivue && window.niivue.Niivue);
  if (!NiiVueClass) { console.error("Niivue not found."); return; }

  const nv = new NiiVueClass({ show3Dcrosshair: true, isWebGL2: true, logging: true });
  nv.attachTo('gl');

  function absUrl(p) { return new URL(p, window.location.href).toString(); }
  function fname(u){ try{const s=u.split('?')[0];return s.substring(s.lastIndexOf('/')+1)||u;}catch{return u;} }

  let base = "./case_00003/"; if (!base.endsWith("/")) base += "/";
  const urlImg  = absUrl(base + "imaging_float32_lowres.nii");
  const urlGT   = absUrl(base + "segmentation_labels_int.nii");
  const urlPred = absUrl(base + "pred_labels_int.nii");
  console.log("Resolved URLs:", { urlImg, urlGT, urlPred });

  async function addVolumeSafe({url, name, colormap, opacity}) {
    const nm = name || fname(url);
    const o = { url, name: nm };
    if (typeof opacity === 'number') o.opacity = opacity;
    if (colormap) o.colormap = colormap;
    return nv.addVolumeFromUrl(o);
  }

  try {
    await addVolumeSafe({ url: urlImg,  name: 'imaging_float32_lowres.nii',  colormap: 'gray', opacity: 1.0 });
    await addVolumeSafe({ url: urlGT,   name: 'segmentation_labels_int.nii', opacity: 0.6 });
    await addVolumeSafe({ url: urlPred, name: 'pred_labels_int.nii',         opacity: 0.6 });
    console.log("All volumes loaded.");
  } catch (e) {
    console.error("Failed to load volumes:", e);
    return;
  }

  const idxGT   = nv.volumes.findIndex(v => v.name === "segmentation_labels_int.nii" || v.name === "GT");
  const idxPred = nv.volumes.findIndex(v => v.name === "pred_labels_int.nii"         || v.name === "Pred");

  function uniqLabels(volIndex, maxLabels=3){
    const v = nv.volumes[volIndex];
    if (!v || !v.img) return [];
    const data = v.img;
    const set = new Set();
    // sample every kth voxel to speed up, but still capture labels
    const step = Math.max(1, Math.floor(data.length / 2e6)); // throttle if very large
    for (let i=0; i<data.length; i+=step){
      const val = data[i];
      if (val !== 0) set.add(val);
      if (set.size > 16) break; // guard
    }
    const arr = Array.from(set).sort((a,b)=>a-b);
    // prefer first 3 smallest as [kidney, tumor, cyst] in that order
    return arr.slice(0, maxLabels);
  }

  // detect actual labels
  const gtVals   = uniqLabels(idxGT);
  const predVals = uniqLabels(idxPred);
  console.log("Detected labels -> GT:", gtVals, "Pred:", predVals);

  // helper: ensure label mode + sane ranges
  function forceLabelMode(i, palette, minVal, maxVal){
    const vol = nv.volumes[i]; if (!vol) return;
    vol.isLabel = true;
    vol.cal_min = (typeof minVal==='number') ? minVal : 0;
    vol.cal_max = (typeof maxVal==='number') ? maxVal : Math.max(3, vol.cal_min+1);
    vol.range   = [vol.cal_min, vol.cal_max];
    vol.colormap = (palette === "warm") ? "warm" : "cool";
  }

  // compute ranges from data (fallback to 0..3)
  const gtMin = (gtVals.length? Math.min(...gtVals) : 0);
  const gtMax = (gtVals.length? Math.max(...gtVals) : 3);
  const prMin = (predVals.length? Math.min(...predVals) : 0);
  const prMax = (predVals.length? Math.max(...predVals) : 3);

  forceLabelMode(idxGT,   "warm", gtMin, gtMax);
  forceLabelMode(idxPred, "cool", prMin, prMax);

  // map UI logical slots -> actual values (fill missing with NaN)
  function mapSlots(vals){
    const a = [NaN, NaN, NaN];
    for (let i=0;i<Math.min(3, vals.length);i++) a[i] = vals[i];
    return a;
  }
  const gtMap   = mapSlots(gtVals);
  const predMap = mapSlots(predVals);

  function makeLUT(palette, alpha1, alpha2, alpha3, mapVals){
    // mapVals: [v1,v2,v3] (could be NaN if not present)
    // Build I: [0, v1, v2, v3], replace NaN with a value not in data to keep it invisible anyway.
    const fill = -123456; // unlikely value
    const I = [0,
      Number.isFinite(mapVals[0]) ? mapVals[0] : fill,
      Number.isFinite(mapVals[1]) ? mapVals[1] : fill,
      Number.isFinite(mapVals[2]) ? mapVals[2] : fill
    ];
    const A = [0,
      Number.isFinite(mapVals[0]) ? alpha1 : 0,
      Number.isFinite(mapVals[1]) ? alpha2 : 0,
      Number.isFinite(mapVals[2]) ? alpha3 : 0
    ];
    if (palette === "warm"){
      return { R:[0,255,255,255], G:[0,140,60,200], B:[0,0,60,0], A, I,
               labels:["background","kidney","tumor","cyst"] };
    } else {
      return { R:[0,0,0,160], G:[0,200,120,0], B:[0,255,255,255], A, I,
               labels:["background","kidney","tumor","cyst"] };
    }
  }

  function setLabelLUT(volIndex, lut, palette){
    const vol = nv.volumes[volIndex]; if (!vol) return;
    vol.isLabel = true;
    vol.colormap = (palette === "warm") ? "warm" : "cool";
    if (typeof nv.setColormapLabel === "function") nv.setColormapLabel(vol.id, lut);
    else { vol.colormapLabel = lut; vol.colorMapLabel = lut; }
    if (typeof nv.refreshColormaps === "function") nv.refreshColormaps();
    nv.updateGLVolume();
  }

  const ON = 255, OFF = 0;

  function applyGT(a1,a2,a3){
    const lut = makeLUT("warm", a1,a2,a3, gtMap);
    setLabelLUT(idxGT, lut, "warm");
  }
  function applyPred(a1,a2,a3){
    const lut = makeLUT("cool", a1,a2,a3, predMap);
    setLabelLUT(idxPred, lut, "cool");
  }

  // init: all on
  applyGT(ON,ON,ON);
  applyPred(ON,ON,ON);

  // global toggles + opacity
  const gtCB   = document.getElementById('showGT');
  const predCB = document.getElementById('showPred');
  const opSL   = document.getElementById('opacity');

  function applyLayerUI() {
    const val = parseFloat(opSL.value);
    if (idxGT   >= 0) nv.volumes[idxGT].opacity  = gtCB.checked   ? val : 0.0;
    if (idxPred >= 0) nv.volumes[idxPred].opacity = predCB.checked ? val : 0.0;
    nv.updateGLVolume();
  }
  gtCB.addEventListener('change', applyLayerUI);
  predCB.addEventListener('change', applyLayerUI);
  opSL.addEventListener('input',  applyLayerUI);
  applyLayerUI();

  // per-label UI
  const gtKidney = document.getElementById('gtKidney');
  const gtTumor  = document.getElementById('gtTumor');
  const gtCyst   = document.getElementById('gtCyst');
  const gtCystNote = document.getElementById('gtCystNote');

  const predKidney = document.getElementById('predKidney');
  const predTumor  = document.getElementById('predTumor');
  const predCyst   = document.getElementById('predCyst');
  const predCystNote = document.getElementById('predCystNote');

  function applyAllLabelVisibility() {
    applyGT(
      gtKidney.checked ? ON : OFF,
      gtTumor.checked  ? ON : OFF,
      gtCyst.checked   ? ON : OFF
    );
    applyPred(
      predKidney.checked ? ON : OFF,
      predTumor.checked  ? ON : OFF,
      predCyst.checked   ? ON : OFF
    );
  }

  gtKidney.addEventListener('change', applyAllLabelVisibility);
  gtTumor .addEventListener('change', applyAllLabelVisibility);
  gtCyst  .addEventListener('change', applyAllLabelVisibility);
  predKidney.addEventListener('change', applyAllLabelVisibility);
  predTumor .addEventListener('change', applyAllLabelVisibility);
  predCyst  .addEventListener('change', applyAllLabelVisibility);

  // disable cyst checkbox if没这个标签
  if (!(gtMap[2] && Number.isFinite(gtMap[2]))) {
    gtCyst.checked = false; gtCyst.disabled = true; gtCystNote.textContent = " (no cyst in GT)";
  }
  if (!(predMap[2] && Number.isFinite(predMap[2]))) {
    predCyst.checked = false; predCyst.disabled = true; predCystNote.textContent = " (no cyst in Pred)";
  }
  applyAllLabelVisibility();
});
</script>
</body>
</html>
